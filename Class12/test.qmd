---
title: "Class 12: Transcriptomics and the analysis of RNA-Seq data"
author: "(Suraj Sidhu: A18512793)"
format: gfm
toc: true
---

## Background

Today we will analyze some RNASeq data from Himes et al. on the effects of a common steroid (dexamethasone) on airwy smooth muscle cells (ASM cells).

Our starting point is the "counts" dat and "metadata" that contain the count values for each gene in their different experiments.

## Data Import

```{r}
counts <- read.csv("airway_scaledcounts.csv", row.names=1)
metadata <-  read.csv("airway_metadata.csv")
```

```{r}
head(counts)
```

> Q1 How many genes are in this dataset ?

```{r}
nrow(counts)
```

> Q2. How many ‘control’ cell lines do we have?

```{r}
table(metadata$dex)
```
## Toy differential gene expression

To start our analysis let's calculate the mean counts for all genes in the control experiments.

1. Extract all "control" columns from the `counts` object.
2. Calculate the mean for all rows (i.e. genes) of these "control" columns
3-4. Do the same for "treated"
5. Compare these `control.mean` and `treated.mean` values.


> Q3. How would you make the above code in either approach more robust? Is there a function that could help here? 

```{r}
control.inds <- metadata$dex == "control"

control.counts <- counts[ ,control.inds]

control.mean <- rowMeans( control.counts )

head(control.mean)
```

> Q4. Follow the same procedure for the treated samples (i.e. calculate the mean per gene across drug treated samples and assign to a labeled vector called treated.mean)

```{r}
treated.inds <- metadata$dex == "treated"

treated.counts <- counts[ ,treated.inds]

treated.mean <- rowMeans( treated.counts )

head(treated.mean)
```
Store these together for easy bookkeeping as `meancounts`
```{r}
meancounts <- data.frame(control.mean, treated.mean)
head(meancounts)
```

> Q5 (a). Create a scatter plot showing the mean of the treated samples against the mean of the control samples.

```{r}
plot(meancounts)
```

> Q5 (b).You could also use the ggplot2 package to make this figure producing the plot below. What geom_?() function would you use for this plot?
We aften talk to metrics like "log2 fold-change"


```{r}
library(ggplot2)
meancounts <- data.frame(
  control = control.mean,
  treated = treated.mean
)

ggplot(meancounts, aes(x = control, y = treated)) +
  geom_point() +
  labs() +
  theme_minimal()

```

```{r}
## treated/control
log2(10/20)
```
> Q6. Try plotting both axes on a log scale. What is the argument to plot() that allows you to do this?

```{r}
# log="xy" applies log scale to both x and y axes
plot(meancounts$control, meancounts$treated,
     xlab = "Control mean counts",
     ylab = "Treated mean counts",
     log = "xy")  

```


Let's calculate the log2 fold change for our treated over our control mean counts. 

```{r}
meancounts$log2fc <- log2(meancounts[,"treated"]/meancounts[,"control"])
```

```{r}
head(meancounts)
```

A common "rule of thumb" is a log2 fold change cutoff of +2 and -2 to call genes "up regulated" or "down regulated"

Number of "up" genes
```{r}
sum(meancounts$log2fc > +2, na.rm =T)
```
Numbers of "down" genes
```{r}
sum(meancounts$log2fc > -2, na.rm =T)
```
```{r}
zero.vals <- which(meancounts[,1:2]==0, arr.ind=TRUE)

to.rm <- unique(zero.vals[,1])
mycounts <- meancounts[-to.rm,]
head(mycounts)

```

> Q7. What is the purpose of the arr.ind argument in the which() function call above? Why would we then take the first column of the output and need to call the unique() function?

arr.ind=TRUE makes which() return row and column indices of zeros. We take the first column to get the gene rows, and unique() ensures each gene is only counted once before removing them.

```{r}
up.ind <- mycounts$log2fc > 2
down.ind <- mycounts$log2fc < (-2)
```

> Q8. Using the up.ind vector above can you determine how many up regulated genes we have at the greater than 2 fc level? 

```{r}
sum(up.ind, na.rm = TRUE)
```

> Q9. Using the down.ind vector above can you determine how many down regulated genes we have at the greater than 2 fc level? 

```{r}
sum(down.ind, na.rm = TRUE)
```

> Q10. Do you trust these results? Why or why not?

No not really because these numbers are just a rough exploratory estimate.


## DESeq Analysis

Let's do this analysis properly and keep your inner stats nerd happy.

```{r, message=FALSE}
library(DESeq2)
```

For DESeq analysis we need 3 things:
1. count values
2. metadata telling us about the columns in `countdata` (`colData`)
3. design of experiment

Our first function form DESeq2 will setup the input require for analysis by storing al these 3 things together.

```{r}
dds <- dds <- DESeqDataSetFromMatrix(countData = counts, 
                              colData = metadata, 
                              design = ~dex)
```

The main function of DESeq2 that runs the analysis is called `DESeq()`

```{r}
dds <- DESeq(dds)
```

```{r}
results(dds)
```

```{r}
res <- results(dds)
head(res)
```

## Volcano Plot

This is common summary result figure from these types of experiments and plot the log2 fold-change vs. the adjusted p-value.

```{r}
plot(res$log2FoldChange, -log(res$padj))
abline(v=c(-2,2),col="red")
```

## Save our Results
```{r}
write.csv(res, file="my_results.csv")
```

